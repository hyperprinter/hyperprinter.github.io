<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HyperPrinter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.0/dist/nipplejs.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="icon" href="./printer.svg" type="image/x-icon" />

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Terminal Styles */
        #terminal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: 500px;
            background: rgba(0, 20, 0, 0.85);
            border: 2px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            color: #0f0;
            overflow: hidden;
            display: none;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            resize: both;
            min-width: 400px;
            min-height: 300px;
            max-width: 90vw;
            max-height: 90vh;
        }
        .mobile #terminal {
            width: 90vw;
            height: 80vh;
            min-width: 300px;
            min-height: 400px;
        }
        .terminal-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            border-bottom: 1px solid #0f0;
            padding-bottom: 5px;
        }
        .terminal-title {
            font-weight: bold;
            text-shadow: 0 0 5px #0f0;
        }
        .terminal-body {
            height: calc(100% - 80px);
            overflow-y: auto;
            padding-right: 10px;
        }
        .command-line {
            display: flex;
            margin-top: 10px;
        }
        .prompt {
            margin-right: 10px;
            color: #0f0;
        }
        .command {
            flex-grow: 1;
            background: transparent;
            border: none;
            color: #0f0;
            font-family: 'Courier New', monospace;
            outline: none;
        }
        .output { line-height: 1.4; margin-bottom: 5px; }
        .success { color: #0f0; }
        .error { color: #f00; }
        .info { color: #0ff; }
        .terminal-body a {
            color: #0ff;
            text-decoration: underline;
            cursor: pointer;
        }
        .terminal-body a:hover {
            color: #0f0;
        }
        .copy-btn {
            background: #0f0;
            color: #000;
            padding: 2px 8px;
            margin-left: 10px;
            cursor: pointer;
            border-radius: 3px;
        }
        .copy-btn:hover {
            background: #0ff;
        }
        .close-btn {
            cursor: pointer;
            color: #f00;
            font-weight: bold;
        }
        .close-btn:hover {
            color: #ff0;
        }

        /* Joystick and Terminal Button */
        #joystick-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            z-index: 100;
            display: none;
        }
        .mobile #joystick-container {
            display: block;
        }
        #terminal-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #0f0;
            color: #000;
            padding: 10px 20px;
            border: 2px solid #0f0;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            z-index: 100;
            display: none;
        }
        .mobile #terminal-btn {
            display: block;
        }
        #terminal-btn.terminal-hidden {
            display: none;
        }
        #terminal-btn:hover {
            background: #0ff;
        }

        /* CRT Effects */
        .crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: overlay;
            animation: noise 0.1s infinite;
        }
        @keyframes noise {
            0% { background-position: 0 0; }
            100% { background-position: 10px 10px; }
        }
        .crt-glow {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(0, 255, 0, 0.05) 0%, transparent 70%);
            pointer-events: none;
            z-index: 9998;
        }
        .scanline {
            position: fixed;
            width: 100%;
            height: 1px;
            background: rgba(0, 255, 0, 0.7);
            animation: scanline 3s linear infinite;
            z-index: 9997;
            pointer-events: none;
        }
        @keyframes scanline {
            0% { top: 0%; }
            100% { top: 100%; }
        }

        /* Coin Animation */
        #printedCoin {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            animation: print-anim 1.5s forwards;
        }
        @keyframes print-anim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.1) rotate(0deg); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2) rotate(10deg); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1) rotate(0deg); }
        }

        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #0f0;
            font-family: 'Courier New', monospace;
            z-index: 100;
        }
        .mobile #instructions {
            bottom: 130px; /* Adjusted for joystick */
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }
        .mobile #crosshair {
            display: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: #0f0;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }

        /* Glitch Effect */
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }
        .glitch-effect {
            animation: glitch 0.5s infinite alternate;
        }

        /* Fallback Message */
        #fallback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f00;
            font-size: 24px;
            text-align: center;
            z-index: 1000;
            display: none;
        }

        /* Landing Page */
        #landing-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 10, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            text-align: center;
        }
        #landing-page h1 {
            font-size: 48px;
            text-shadow: 0 0 10px #0f0;
            animation: glitch 0.5s infinite alternate;
            margin-bottom: 20px;
        }
        #landing-page p {
            font-size: 24px;
            margin-bottom: 20px;
        }
        #landing-page .prompt {
            font-size: 18px;
            color: #0ff;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body class="bg-black text-green-400">
    <!-- Landing Page -->
    <div id="landing-page">
        <h1 class="glitch-effect">HYPERPRINTER COIN GALLERY</h1>
        <p>Welcome to the Future of Digital Collectibles</p>
        <p class="prompt">Click Anywhere to Enter</p>
    </div>

    <!-- 3D Scene -->
    <div id="crosshair"></div>
    <div id="instructions">Click to enable controls | WASD to move | E to interact | T for info in terminal</div>
    <div id="fallback">Error: 3D Scene Failed to Load. Check Console for Details.</div>

    <!-- Terminal Interface -->
    <div id="terminal">
        <div class="terminal-header">
            <div class="terminal-title glitch-effect">HYPERPRINTER TERMINAL v2.0</div>
            <div>
                <span class="terminal-status">STATUS: <span class="success">ACTIVE</span></span>
                <span class="close-btn" onclick="closeTerminal()">X</span>
            </div>
        </div>
        <div class="terminal-body" id="terminalOutput"></div>
        <div class="command-line">
            <span class="prompt">></span>
            <input type="text" class="command" id="terminalInput" autocomplete="off">
        </div>
    </div>

    <!-- Joystick and Terminal Button -->
    <div id="joystick-container"></div>
    <button id="terminal-btn" onclick="toggleTerminal()">Terminal</button>

    <!-- Printed Coin Display -->
    <div id="printedCoin" class="coin-print">
        <div class="relative">
            <div class="w-64 h-64 bg-black rounded-full border-4 border-green-400 flex items-center justify-center shadow-xl shadow-green-400/50">
                <div class="text-8xl font-bold">HYPERPRINT</div>
            </div>
            <div class="absolute -bottom-8 left-0 right-0 text-center text-sm">
                PRINTED: <span id="printTime"></span>
            </div>
        </div>
    </div>

    <!-- CRT Effects -->
    <div class="crt-overlay"></div>
    <div class="crt-glow"></div>
    <div class="scanline" id="scanline"></div>

    <script>
        // Detect mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
        if (isMobile) {
            document.body.classList.add('mobile');
            document.getElementById('instructions').textContent = 'Use joystick to move | Drag to look | Tap Terminal for info';
        }

        // Hide landing page on click/touch
        const landingPage = document.getElementById('landing-page');
        landingPage.addEventListener('click', () => {
            landingPage.style.display = 'none';
            if (!isMobile) {
                renderer.domElement.requestPointerLock();
            }
            console.log("Landing page dismissed");
        });
        landingPage.addEventListener('touchstart', (e) => {
            e.preventDefault();
            landingPage.style.display = 'none';
            console.log("Landing page dismissed via touch");
        });

        // Debug logging
        console.log("Starting Three.js setup...");

        // Initialize Three.js scene
        let scene, camera, renderer, controls;
        try {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.zIndex = 1;
            document.body.appendChild(renderer.domElement);
            console.log("Renderer initialized successfully");
        } catch (e) {
            console.error("Failed to initialize Three.js:", e);
            document.getElementById('fallback').style.display = 'block';
            document.getElementById('instructions').textContent = 'Error: WebGL initialization failed. Check console.';
        }

        // Room (Walls)
        try {
            const roomGeometry = new THREE.BoxGeometry(20, 20, 20);
            const roomMaterial = new THREE.MeshStandardMaterial({
                color: 0xD2B48C,
                side: THREE.BackSide,
                roughness: 0.8
            });
            const room = new THREE.Mesh(roomGeometry, roomMaterial);
            scene.add(room);
            console.log("Room (walls) added to scene with light brown (0xD2B48C)");
        } catch (e) {
            console.error("Failed to create room:", e);
        }

        // Floor
        try {
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            scene.add(floor);
            console.log("Floor added to scene");
        } catch (e) {
            console.error("Failed to create floor:", e);
        }

        // Ceiling
        try {
            const ceilingGeometry = new THREE.PlaneGeometry(20, 20);
            const ceilingMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 8;
            scene.add(ceiling);
            console.log("Ceiling added to scene");
        } catch (e) {
            console.error("Failed to create ceiling:", e);
        }

        // Light Bulb
        let bulb, bulbLight;
        try {
            const bulbGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const bulbMaterial = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 0.5
            });
            bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.set(0, 7.7, 0);
            scene.add(bulb);
            bulbLight = new THREE.PointLight(0xffff00, 1, 15);
            bulbLight.position.set(0, 7.7, 0);
            scene.add(bulbLight);
            console.log("Light bulb and light added to scene");
        } catch (e) {
            console.error("Failed to create light bulb:", e);
        }

        // Create fallback texture
        function createFallbackTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            context.fillStyle = '#333333';
            context.fillRect(0, 0, 256, 256);
            context.fillStyle = '#ff0000';
            context.font = 'bold 30px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('Image Failed', 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        // Pictures
        let pictures = [];
        let currentPictureSet = 1;
        async function loadPictures() {
            try {
                const pictureGeometry = new THREE.PlaneGeometry(3.0, 2.25);
                const frameMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.7
                });

                const textureLoader = new THREE.TextureLoader();
                const fallbackTexture = createFallbackTexture();
                const imageFiles = [
                    'slika_1.jpeg', 'slika_2.jpeg', 'slika_3.jpeg', 'slika_4.jpeg', 'slika_5.jpeg', 'slika_6.jpeg',
                    'slika_7.jpeg', 'slika_8.jpeg', 'slika_9.jpeg', 'slika_10.jpeg', 'slika_11.jpeg', 'slika_12.jpeg'
                ];

                const loadTexture = (file) => {
                    return new Promise((resolve) => {
                        textureLoader.load(
                            file,
                            (texture) => {
                                console.log(`Texture loaded: ${file}`);
                                resolve(texture);
                            },
                            undefined,
                            (error) => {
                                console.error(`Failed to load texture: ${file}`, error);
                                resolve(fallbackTexture);
                            }
                        );
                    });
                };

                const pictureMaterialsSet1 = [];
                const pictureMaterialsSet2 = [];
                for (let i = 0; i < 6; i++) {
                    const texture1 = await loadTexture(imageFiles[i]);
                    pictureMaterialsSet1.push(new THREE.MeshStandardMaterial({ map: texture1, emissive: 0x111111 }));
                    const texture2 = await loadTexture(imageFiles[i + 6]);
                    pictureMaterialsSet2.push(new THREE.MeshStandardMaterial({ map: texture2, emissive: 0x111111 }));
                }

                const pictureConfigs = [
                    { name: 'slika_1', x: -9.85, z: -5, rotation: Math.PI / 2 },
                    { name: 'slika_2', x: -9.85, z: 0, rotation: Math.PI / 2 },
                    { name: 'slika_3', x: -9.85, z: 5, rotation: Math.PI / 2 },
                    { name: 'slika_4', x: 9.85, z: -5, rotation: -Math.PI / 2 },
                    { name: 'slika_5', x: 9.85, z: 0, rotation: -Math.PI / 2 },
                    { name: 'slika_6', x: 9.85, z: 5, rotation: -Math.PI / 2 }
                ];

                pictures = pictureConfigs.map((pic, i) => {
                    const frame = new THREE.Mesh(new THREE.PlaneGeometry(2.8, 2.05), frameMaterial);
                    frame.position.set(pic.x > 0 ? 9.9 : -9.9, 3, pic.z);
                    frame.rotation.y = pic.rotation;
                    scene.add(frame);
                    const picture = new THREE.Mesh(pictureGeometry, pictureMaterialsSet1[i]);
                    picture.position.set(pic.x, 3, pic.z);
                    picture.rotation.y = pic.rotation;
                    picture.name = pic.name;
                    scene.add(picture);
                    return { mesh: picture, frame: frame, config: pic, materialSet1: pictureMaterialsSet1[i], materialSet2: pictureMaterialsSet2[i] };
                });
                console.log("Pictures added to scene with size 3.0x2.25");
            } catch (e) {
                console.error("Failed to create pictures:", e);
            }
        }
        loadPictures();

        function updatePictures() {
            const isSet1 = currentPictureSet === 1;
            pictures.forEach(pic => {
                pic.mesh.material = isSet1 ? pic.materialSet2 : pic.materialSet1;
                pic.mesh.name = isSet1 ? `slika_${pic.config.name.split('_')[1] * 1 + 6}` : pic.config.name;
            });
            currentPictureSet = isSet1 ? 2 : 1;
            console.log(`Pictures updated to set ${currentPictureSet}`);
        }

        // Press Me Button
        let pressButton;
        try {
            const buttonGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 32);
            const buttonMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.5
            });
            pressButton = new THREE.Mesh(buttonGeometry, buttonMaterial);
            pressButton.position.set(0, 2, -9.9);
            pressButton.rotation.x = Math.PI / 2;
            pressButton.name = 'pressButton';
            scene.add(pressButton);
            console.log("Button added to scene");
        } catch (e) {
            console.error("Failed to create button:", e);
        }

        // Press Me Label
        try {
            const canvas = document.createElement('canvas');
            canvas.width = 600;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(0, 0, 0, 0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.font = 'bold 50px Courier New';
            context.fillStyle = '#00ff00';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('Press me for print', canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const labelGeometry = new THREE.PlaneGeometry(3.5, 0.5);
            const labelMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            const label = new THREE.Mesh(labelGeometry, labelMaterial);
            label.position.set(0, 2.7, -9.8);
            label.rotation.y = Math.PI * 2;
            scene.add(label);
            console.log("Label 'Press me for print' added at position (0, 2.7, -9.8)");
        } catch (e) {
            console.error("Failed to create label:", e);
        }

        // Lighting
        try {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            console.log("Ambient lighting added to scene");
        } catch (e) {
            console.error("Failed to create lighting:", e);
        }

        // Camera position
        camera.position.set(0, 1.6, 0);
        console.log("Camera positioned");

        // Pointer lock controls
        let isLocked = !isMobile;
        let isNearButton = false;
        try {
            controls = new THREE.PointerLockControls(camera, renderer.domElement);
            console.log("PointerLockControls initialized");
        } catch (e) {
            console.error("Failed to initialize PointerLockControls:", e);
            document.getElementById('fallback').style.display = 'block';
        }

        // Joystick setup for mobile
        let joystickMove = { x: 0, z: 0 };
        if (isMobile) {
            const joystickContainer = document.getElementById('joystick-container');
            try {
                const joystick = nipplejs.create({
                    zone: joystickContainer,
                    mode: 'static',
                    position: { left: '50%', top: '50%' },
                    color: 'green',
                    size: 100,
                    threshold: 0.1
                });
                joystick.on('move', (evt, data) => {
                    if (data.vector) {
                        // Map joystick input to match desktop controls
                        // data.vector.y: positive = up (forward), negative = down (backward)
                        // data.vector.x: negative = left, positive = right
                        const magnitude = Math.min(1, Math.sqrt(data.vector.x ** 2 + data.vector.y ** 2));
                        joystickMove.x = data.vector.x / (magnitude || 1) * 0.1; // Sideways (left/right)
                        joystickMove.z = -data.vector.y / (magnitude || 1) * 0.1; // Forward/backward
                        console.log(`Joystick move: x=${joystickMove.x}, z=${joystickMove.z}`);
                    }
                });
                joystick.on('end', () => {
                    joystickMove = { x: 0, z: 0 };
                    console.log("Joystick released");
                });
                console.log("Joystick initialized for mobile");
            } catch (e) {
                console.error("Failed to initialize joystick:", e);
            }
        }

        // Inverted drag-to-look for mobile
        let isDragging = false;
        let previousTouchX = 0;
        let previousTouchY = 0;
        if (isMobile) {
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1 && !isTerminalOpen && landingPage.style.display === 'none') {
                    isDragging = true;
                    previousTouchX = e.touches[0].clientX;
                    previousTouchY = e.touches[0].clientY;
                }
            });
            renderer.domElement.addEventListener('touchmove', (e) => {
                if (isDragging && e.touches.length === 1 && !isTerminalOpen && landingPage.style.display === 'none') {
                    const deltaX = e.touches[0].clientX - previousTouchX;
                    const deltaY = e.touches[0].clientY - previousTouchY;
                    const sensitivity = 0.005;
                    controls.getObject().rotation.y += deltaX * sensitivity;
                    const newPitch = camera.rotation.x + deltaY * sensitivity;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, newPitch));
                    camera.rotation.z = 0;
                    previousTouchX = e.touches[0].clientX;
                    previousTouchY = e.touches[0].clientY;
                    camera.rotation.x=0;
                }
            });
            renderer.domElement.addEventListener('touchend', () => {
                isDragging = false;
            });
            console.log("Inverted drag-to-look initialized for mobile (yaw and pitch, no roll)");
        }

        // Event listeners for pointer lock (desktop only)
        if (!isMobile) {
            renderer.domElement.addEventListener('click', () => {
                if (!isTerminalOpen && landingPage.style.display === 'none') {
                    console.log("Click detected, requesting pointer lock");
                    renderer.domElement.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === renderer.domElement) {
                    isLocked = true;
                    document.getElementById('instructions').textContent = 'WASD to move | E to interact | T for info in terminal';
                    console.log("Pointer lock enabled");
                } else {
                    isLocked = false;
                    document.getElementById('instructions').textContent = 'Click to enable controls | WASD to move | E to interact | T for info in terminal';
                    console.log("Pointer lock disabled");
                }
            });

            document.addEventListener('pointerlockerror', () => {
                console.error("Pointer lock error occurred");
                document.getElementById('instructions').textContent = 'Pointer lock failed. Try another browser or host on a server.';
            });
        }

        // Terminal functionality
        const terminal = document.getElementById('terminal');
        const terminalOutput = document.getElementById('terminalOutput');
        const terminalInput = document.getElementById('terminalInput');
        const terminalBtn = document.getElementById('terminal-btn');
        let isTerminalOpen = false;
        let commandHistory = [];
        let historyIndex = -1;

        const commands = {
            help: {
                desc: "Display available commands",
                execute: () => {
                    printToTerminal("> help", "command");
                    printToTerminal("Available commands:", "info");
                    printToTerminal("----------------", "info");
                    printToTerminal("help - Display available commands", "info");
                    printToTerminal("about - Describe HyperPrinter coin", "info");
                    printToTerminal("contract - Show contract address", "info");
                    printToTerminal("social - Show social media links", "info");
                    printToTerminal("buy - How to buy $HYPERPRINT instructions", "info");
                }
            },
            about: {
                desc: "Describe HyperPrinter coin",
                execute: () => {
                    printToTerminal("ABOUT", "info");
                    printToTerminal("Hyper Printer is a reward-based token built on the Hyper EVM chain. It automatically rewards holders with the native $HYPER token, promoting long-term holding and community growth.", "info");
                    printToTerminal("Our goal is to create a sustainable ecosystem where users benefit simply by holding.", "info");
                    printToTerminal("$HYPERPRINTERNOMICS", "info");
                    printToTerminal("LIQUIDITY: BURNED", "info");
                    printToTerminal("OWNERSHIP: RENOUNCED", "info");
                    printToTerminal("TAX: 2/2 to $HYPE rewards", "info");
                    printToTerminal("SUPPLY: 1,000,000,000", "info");
                }
            },
            contract: {
                desc: "Show contract address",
                execute: () => {
                    const contractAddress = "0xE95705139b7bA5e7DF2f315D71f572453d697043";
                    printToTerminal(`Contract Address: ${contractAddress} <span class="copy-btn" onclick="navigator.clipboard.writeText('${contractAddress}').then(() => alert('Copied!'))">Copy</span>`, "info", true);
                }
            },
            social: {
                desc: "Show social media links",
                execute: () => {
                    printToTerminal("Social Media:", "info");
                    printToTerminal('<a href="https://x.com/Hyper_Printer" target="_blank">Twitter</a>', "info", true);
                    printToTerminal('<a href="https://t.me/hyperprintertg" target="_blank">Telegram</a>', "info", true);
                    printToTerminal('<a href="https://t.me/HyperprinterBot" target="_blank">Rewards Bot</a>', "info", true);
                    printToTerminal('<a href="https://docs.hyperprinter.xyz/" target="_blank">Docs</a>', "info", true);
                }
            },
            buy: {
                desc: "How to buy $HYPERPRINT instructions",
                execute: () => {
                    printToTerminal("HOW TO BUY ?", "info");
                    printToTerminal("1. Add chain to MetaMask", "info");
                    printToTerminal("First things first, you'll need to install the MetaMask wallet. Since the HyperChain is new, you'll need to manually add the chain to your wallet.", "info");
                    printToTerminal('The RPC endpoint is: <a href="https://rpc.hyperliquid.xyz/evm" target="_blank">https://rpc.hyperliquid.xyz/evm</a>', "info", true);
                    printToTerminal("The Chain ID is: 999", "info");
                    printToTerminal("Symbol: $HYPE", "info");
                    printToTerminal("2. Get $HYPE", "info");
                    printToTerminal("Go to your favorite exchange, buy some HYPE, and then send it directly to your MetaMask wallet. After selecting the previously added chain, you should be able to see your HYPE tokens.", "info");
                    printToTerminal("3. Buy $HYPERPRINT", "info");
                    printToTerminal('Visit <a href="https://app.hyperswap.exchange" target="_blank">https://app.hyperswap.exchange</a>', "info", true);
                    printToTerminal("Swap your $HYPE for $HYPERPRINT using the official contract address (CA) found on our page!", "info");
                }
            }
        };

        function printToTerminal(text, type = "", isHtml = false) {
            const line = document.createElement('div');
            line.className = `output ${type}`;
            if (isHtml) {
                line.innerHTML = text;
            } else {
                line.textContent = text;
            }
            terminalOutput.appendChild(line);
            terminalOutput.scrollTop = terminalOutput.scrollHeight;
        }

        function activateTerminal() {
            isTerminalOpen = true;
            terminal.style.display = 'block';
            terminalBtn.classList.add('terminal-hidden');
            terminalInput.focus();
            if (!isMobile) document.exitPointerLock();
            isLocked = !isMobile;
            printToTerminal("HyperPrinter online. $TERMINAL READY", "success");
            commands.help.execute();
            console.log("Terminal activated");
        }

        window.closeTerminal = function() {
            isTerminalOpen = false;
            terminal.style.display = 'none';
            terminalBtn.classList.remove('terminal-hidden');
            console.log("Terminal closed");
        };

        window.toggleTerminal = function() {
            if (isTerminalOpen) {
                closeTerminal();
            } else {
                activateTerminal();
            }
        };

        terminalInput.addEventListener('keydown', (e) => {
            if (!isTerminalOpen) return;
            if (e.key === 'Enter') {
                const command = terminalInput.value.trim();
                terminalInput.value = '';
                if (command) {
                    commandHistory.push(command);
                    historyIndex = commandHistory.length;
                    printToTerminal(`> ${command}`, "command");
                    if (commands[command]) {
                        commands[command].execute();
                    } else {
                        printToTerminal(`Command not found: ${command}`, "error");
                        printToTerminal(`Type 'help' for available commands`, "info");
                    }
                }
            } else if (e.key === 'ArrowUp') {
                if (commandHistory.length > 0) {
                    if (historyIndex > -1) historyIndex--;
                    terminalInput.value = commandHistory[historyIndex] || '';
                }
            } else if (e.key === 'ArrowDown') {
                if (commandHistory.length > 0) {
                    if (historyIndex < commandHistory.length - 1) historyIndex++;
                    terminalInput.value = commandHistory[historyIndex] || '';
                }
            }
        });

        // Keyboard controls
        const keyState = {};
        let isTerminalInputLocked = false;
        document.addEventListener('keydown', (e) => {
            if (landingPage.style.display !== 'none') return;
            if (isTerminalOpen && !isTerminalInputLocked && e.key.toLowerCase() === 't') {
                return;
            }
            if (isTerminalOpen && e.key.toLowerCase() === 'x') {
                closeTerminal();
                isTerminalInputLocked = false;
                return;
            }
            if (isTerminalOpen || isMobile) {
                return;
            }
            keyState[e.key.toLowerCase()] = true;
            if (e.key.toLowerCase() === 'e' && isNearButton) {
                triggerButtonEffects();
                console.log("Button pressed");
            }
            if (e.key.toLowerCase() === 't') {
                activateTerminal();
                isTerminalInputLocked = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            keyState[e.key.toLowerCase()] = false;
        });

        // Mobile interaction (tap near button)
        if (isMobile) {
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (landingPage.style.display !== 'none' || isTerminalOpen) return;
                if (isNearButton) {
                    triggerButtonEffects();
                    console.log("Button activated via tap");
                }
            });
        }

        // Button effects
        function triggerButtonEffects() {
            pressButton.position.z = -10.05;
            setTimeout(() => {
                pressButton.position.z = -9.9;
            }, 500);

            const now = new Date();
            document.getElementById('printTime').textContent = now.toLocaleTimeString();
            document.getElementById('printedCoin').style.display = 'block';
            setTimeout(() => {
                document.getElementById('printedCoin').style.display = 'none';
            }, 3000);

            let flickerCount = 0;
            const flickerInterval = setInterval(() => {
                bulbLight.intensity = flickerCount % 2 === 0 ? 0 : 1;
                bulb.material.emissiveIntensity = flickerCount % 2 === 0 ? 0 : 0.5;
                flickerCount++;
                if (flickerCount >= 8) {
                    clearInterval(flickerInterval);
                    bulbLight.intensity = 1;
                    bulb.material.emissiveIntensity = 0.5;
                }
            }, 200);

            updatePictures();
        }

        // Movement function with collision detection
        function handleMovement() {
            if (!isLocked && !isMobile || isTerminalOpen || landingPage.style.display !== 'none') return;
            const moveSpeed = 0.1;
            const moveVector = new THREE.Vector3();
            if (isMobile) {
                // Use joystick input directly for moveRight and moveForward
                // joystickMove.z: positive = forward, negative = backward
                // joystickMove.x: negative = left, positive = right
                moveVector.x = joystickMove.x; // Sideways movement
                moveVector.z = -joystickMove.z; // Forward/backward movement
            } else {
                if (keyState['s']) moveVector.z -= moveSpeed; // Forward
                if (keyState['w']) moveVector.z += moveSpeed; // Backward
                if (keyState['a']) moveVector.x -= moveSpeed; // Left
                if (keyState['d']) moveVector.x += moveSpeed; // Right
            }

            const currentPosition = controls.getObject().position.clone();
            controls.moveRight(moveVector.x);
            controls.moveForward(moveVector.z);

            const newPosition = controls.getObject().position;
            const roomHalfSize = 10;
            let hitWall = false;

            if (newPosition.x < -roomHalfSize + 0.2) {
                newPosition.x = -roomHalfSize + 0.2;
                hitWall = true;
            }
            if (newPosition.x > roomHalfSize - 0.2) {
                newPosition.x = roomHalfSize - 0.2;
                hitWall = true;
            }
            if (newPosition.z < -roomHalfSize + 0.2) {
                newPosition.z = -roomHalfSize + 0.2;
                hitWall = true;
            }
            if (newPosition.z > roomHalfSize - 0.2) {
                newPosition.z = roomHalfSize - 0.2;
                hitWall = true;
            }
            if (newPosition.y < 1.6) {
                newPosition.y = 1.6;
            }
            if (newPosition.y > 7.5) {
                newPosition.y = 7.5;
            }

            if (hitWall) {
                controls.getObject().position.copy(newPosition);
            }

            const cameraPosition = controls.getObject().position;
            const distanceToButton = cameraPosition.distanceTo(pressButton.position);
            isNearButton = distanceToButton < 2;
            document.getElementById('instructions').textContent = isMobile
                ? (isNearButton ? 'Tap to activate button | Drag to look | Tap Terminal for info' : 'Use joystick to move | Drag to look | Tap Terminal for info')
                : (isNearButton ? 'Press E to activate button | T for info in terminal' : 'WASD to move | T for info in terminal');
        }

        // Scanline text refresh
        const scanline = document.getElementById('scanline');
        const allTextElements = Array.from(document.querySelectorAll('.terminal, .terminal-title, .command-line, .output, .prompt, .command, #instructions, #terminal-btn, #landing-page h1, #landing-page p'));
        function randomFade() {
            allTextElements.forEach(el => {
                if (Math.random() > 0.7) {
                    el.style.opacity = Math.max(0.5, Math.random() * 0.8);
                }
            });
            setTimeout(randomFade, 1000);
        }
        randomFade();
        scanline.addEventListener('animationiteration', () => {
            allTextElements.forEach((el, i) => {
                setTimeout(() => {
                    el.style.opacity = 1;
                    el.style.textShadow = '0 0 10px #0f0';
                    setTimeout(() => {
                        el.style.textShadow = '0 0 5px #0f0';
                    }, 1000);
                }, i * 50);
            });
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            handleMovement();
            try {
                renderer.render(scene, camera);
            } catch (e) {
                console.error("Rendering error:", e);
                document.getElementById('fallback').style.display = 'block';
            }
        }

        animate();
        console.log("Animation loop started");

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            console.log("Window resized");
        });

        // Initial debug message
        console.log("Scene setup complete. If only text is visible, check console errors or WebGL support.");
    </script>
</body>
</html>
